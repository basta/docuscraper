--- Content from https://typer.tiangolo.com/ ---

Typer Typer, build great CLIs. Easy to code. Based on Python type hints. Documentation : https://typer.tiangolo.com Source Code : https://github.com/fastapi/typer Typer is a library for building CLI applications that users will love using and developers will love creating . Based on Python type hints. It's also a command line tool to run scripts, automatically converting them to CLI applications. The key features are: Intuitive to write : Great editor support. Completion everywhere. Less time debugging. Designed to be easy to use and learn. Less time reading docs. Easy to use : It's easy to use for the final users. Automatic help, and automatic completion for all shells. Short : Minimize code duplication. Multiple features from each parameter declaration. Fewer bugs. Start simple : The simplest example adds only 2 lines of code to your app: 1 import, 1 function call . Grow large : Grow in complexity as much as you want, create arbitrarily complex trees of commands and groups of subcommands, with options and arguments. Run scripts : Typer includes a typer command/program that you can use to run scripts, automatically converting them to CLIs, even if they don't use Typer internally. FastAPI of CLIs ¶ Typer is FastAPI 's little sibling, it's the FastAPI of CLIs. Installation ¶ Create and activate a virtual environment and then install Typer : $ pip install typer ---> 100% Successfully installed typer rich shellingham Example ¶ The absolute minimum ¶ Create a file main.py with: def main ( name : str ): print ( f "Hello { name } " ) This script doesn't even use Typer internally. But you can use the typer command to run it as a CLI application. Run it ¶ Run your application with the typer command: // Run your application $ typer main.py run // You get a nice error, you are missing NAME Usage: typer [PATH_OR_MODULE] run [OPTIONS] NAME Try 'typer [PATH_OR_MODULE] run --help' for help. ╭─ Error ───────────────────────────────────────────╮ │ Missing argument 'NAME'. │ ╰───────────────────────────────────────────────────╯ // You get a --help for free $ typer main.py run --help Usage: typer [PATH_OR_MODULE] run [OPTIONS] NAME Run the provided Typer app. ╭─ Arguments ───────────────────────────────────────╮ │ * name TEXT [default: None] [required] | ╰───────────────────────────────────────────────────╯ ╭─ Options ─────────────────────────────────────────╮ │ --help Show this message and exit. │ ╰───────────────────────────────────────────────────╯ // Now pass the NAME argument $ typer main.py run Camila Hello Camila // It works! 🎉 This is the simplest use case, not even using Typer internally, but it can already be quite useful for simple scripts. Note : auto-completion works when you create a Python package and run it with --install-completion or when you use the typer command. Use Typer in your code ¶ Now let's start using Typer in your own code, update main.py with: import typer def main ( name : str ): print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) Now you could run it with Python directly: // Run your application $ python main.py // You get a nice error, you are missing NAME Usage: main.py [OPTIONS] NAME Try 'main.py --help' for help. ╭─ Error ───────────────────────────────────────────╮ │ Missing argument 'NAME'. │ ╰───────────────────────────────────────────────────╯ // You get a --help for free $ python main.py --help Usage: main.py [OPTIONS] NAME ╭─ Arguments ───────────────────────────────────────╮ │ * name TEXT [default: None] [required] | ╰───────────────────────────────────────────────────╯ ╭─ Options ─────────────────────────────────────────╮ │ --help Show this message and exit. │ ╰───────────────────────────────────────────────────╯ // Now pass the NAME argument $ python main.py Camila Hello Camila // It works! 🎉 Note : you can also call this same script with the typer command, but you don't need to. Example upgrade ¶ This was the simplest example possible. Now let's see one a bit more complex. An example with two subcommands ¶ Modify the file main.py . Create a typer.Typer() app, and create two subcommands with their parameters. import typer app = typer . Typer () @app . command () def hello ( name : str ): print ( f "Hello { name } " ) @app . command () def goodbye ( name : str , formal : bool = False ): if formal : print ( f "Goodbye Ms. { name } . Have a good day." ) else : print ( f "Bye { name } !" ) if __name__ == "__main__" : app () And that will: Explicitly create a typer.Typer app. The previous typer.run actually creates one implicitly for you. Add two subcommands with @app.command() . Execute the app() itself, as if it was a function (instead of typer.run ). Run the upgraded example ¶ Check the new help: $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... ╭─ Options ─────────────────────────────────────────╮ │ --install-completion Install completion │ │ for the current │ │ shell. │ │ --show-completion Show completion for │ │ the current shell, │ │ to copy it or │ │ customize the │ │ installation. │ │ --help Show this message │ │ and exit. │ ╰───────────────────────────────────────────────────╯ ╭─ Commands ────────────────────────────────────────╮ │ goodbye │ │ hello │ ╰───────────────────────────────────────────────────╯ // When you create a package you get ✨ auto-completion ✨ for free, installed with --install-completion // You have 2 subcommands (the 2 functions): goodbye and hello Now check the help for the hello command: $ python main.py hello --help Usage: main.py hello [OPTIONS] NAME ╭─ Arguments ───────────────────────────────────────╮ │ * name TEXT [default: None] [required] │ ╰───────────────────────────────────────────────────╯ ╭─ Options ─────────────────────────────────────────╮ │ --help Show this message and exit. │ ╰───────────────────────────────────────────────────╯ And now check the help for the goodbye command: $ python main.py goodbye --help Usage: main.py goodbye [OPTIONS] NAME ╭─ Arguments ───────────────────────────────────────╮ │ * name TEXT [default: None] [required] │ ╰───────────────────────────────────────────────────╯ ╭─ Options ─────────────────────────────────────────╮ │ --formal --no-formal [default: no-formal] │ │ --help Show this message │ │ and exit. │ ╰───────────────────────────────────────────────────╯ // Automatic --formal and --no-formal for the bool option 🎉 Now you can try out the new command line application: // Use it with the hello command $ python main.py hello Camila Hello Camila // And with the goodbye command $ python main.py goodbye Camila Bye Camila! // And with --formal $ python main.py goodbye --formal Camila Goodbye Ms. Camila. Have a good day. Recap ¶ In summary, you declare once the types of parameters ( CLI arguments and CLI options ) as function parameters. You do that with standard modern Python types. You don't have to learn a new syntax, the methods or classes of a specific library, etc. Just standard Python . For example, for an int : total : int or for a bool flag: force : bool And similarly for files , paths , enums (choices), etc. And there are tools to create groups of subcommands , add metadata, extra validation , etc. You get : great editor support, including completion and type checks everywhere. Your users get : automatic --help , auto-completion in their terminal (Bash, Zsh, Fish, PowerShell) when they install your package or when using the typer command. For a more complete example including more features, see the Tutorial - User Guide . Dependencies ¶ Typer stands on the shoulders of a giant. Its only internal required dependency is Click . By default it also comes with extra standard dependencies: rich : to show nicely formatted errors automatically. shellingham : to automatically detect the current shell when installing completion. With shellingham you can just use --install-completion . Without shellingham , you have to pass the name of the shell to install completion for, e.g. --install-completion bash . typer-slim ¶ If you don't want the extra standard optional dependencies, install typer-slim instead. When you install with: pip install typer ...it includes the same code and dependencies as: pip install "typer-slim[standard]" The standard extra dependencies are rich and shellingham . Note : The typer command is only included in the typer package. License ¶ This project is licensed under the terms of the MIT license.

--- Content from https://typer.tiangolo.com/tutorial/commands/ ---

Typer Learn Commands Commands ¶ We have seen how to create a CLI program with possibly several CLI options and CLI arguments . But Typer allows you to create CLI programs with several commands (also known as subcommands). For example, the program git has several commands. One command of git is git push . And git push in turn takes its own CLI arguments and CLI options . For example: // The push command with no parameters $ git push ---> 100% // The push command with one CLI option --set-upstream and 2 CLI arguments $ git push --set-upstream origin master ---> 100% Another command of git is git pull , it also has some CLI parameters . It's like if the same big program git had several small programs inside. Tip A command looks the same as a CLI argument , it's just some name without a preceding -- . But commands have a predefined name, and are used to group different sets of functionalities into the same CLI application. Command or subcommand ¶ It's common to call a CLI program a "command". But when one of these programs have subcommands, those subcommands are also frequently called just "commands". Have that in mind so you don't get confused. Here I'll use CLI application or program to refer to the program you are building in Python with Typer, and command to refer to one of these "subcommands" of your program. Explicit application ¶ Before creating CLI applications with multiple commands/subcommands we need to understand how to create an explicit typer.Typer() application. In the CLI options and CLI argument tutorials you have seen how to create a single function and then pass that function to typer.run() . For example: Python 3.8+ import typer def main ( name : str ): print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) But that is actually a shortcut. Under the hood, Typer converts that to a CLI application with typer.Typer() and executes it. All that inside of typer.run() . There's also a more explicit way to achieve the same: Python 3.8+ import typer app = typer . Typer () @app . command () def main ( name : str ): print ( f "Hello { name } " ) if __name__ == "__main__" : app () When you use typer.run() , Typer is doing more or less the same as above, it will: Create a new typer.Typer() "application". Create a new " command " with your function. Call the same "application" as if it was a function with " app() ". @decorator Info That @something syntax in Python is called a "decorator". You put it on top of a function. Like a pretty decorative hat (I guess that's where the term came from). A "decorator" takes the function below and does something with it. In our case, this decorator tells Typer that the function below is a " command ". Both ways, with typer.run() and creating the explicit application, achieve almost the same. Tip If your use case is solved with just typer.run() , that's fine, you don't have to create the explicit app and use @app.command() , etc. You might want to do that later when your app needs the extra features, but if it doesn't need them yet, that's fine. If you run the second example, with the explicit app , it works exactly the same: // Without a CLI argument $ python main.py Usage: main.py [OPTIONS] NAME Try "main.py --help" for help. Error: Missing argument 'NAME'. // With the NAME CLI argument $ python main.py Camila Hello Camila // Asking for help $ python main.py --help Usage: main.py [OPTIONS] NAME Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. CLI application completion ¶ There's a little detail that is worth noting here. Now the help shows two new CLI options : --install-completion --show-completion To get shell/tab completion, it's necessary to build a package that you and your users can install and call directly . So instead of running a Python script like: $ python main.py ✨ Some magic here ✨ ...It would be called like: $ magic-app ✨ Some magic here ✨ Having a standalone program like that allows setting up shell/tab completion. The first step to be able to create an installable package like that is to use an explicit typer.Typer() app. Later you can learn all the process to create a standalone CLI application and Build a Package . But for now, it's just good to know that you are on that path. 😎 A CLI application with multiple commands ¶ Coming back to the CLI applications with multiple commands/subcommands, Typer allows creating CLI applications with multiple of them. Now that you know how to create an explicit typer.Typer() application and add one command, let's see how to add multiple commands. Let's say that we have a CLI application to manage users. We'll have a command to create users and another command to delete them. To begin, let's say it can only create and delete one single predefined user: Python 3.8+ import typer app = typer . Typer () @app . command () def create (): print ( "Creating user: Hiro Hamada" ) @app . command () def delete (): print ( "Deleting user: Hiro Hamada" ) if __name__ == "__main__" : app () Now we have a CLI application with 2 commands, create and delete : // Check the help $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create delete // Test them $ python main.py create Creating user: Hiro Hamada $ python main.py delete Deleting user: Hiro Hamada // Now we have 2 commands! 🎉 Notice that the help text now shows the 2 commands: create and delete . Tip By default, the names of the commands are generated from the function name. Show the help message if no command is given ¶ By default, we need to specify --help to get the command's help page. However, by setting no_args_is_help=True when defining the typer.Typer() application, the help function will be shown whenever no argument is given: Python 3.8+ import typer app = typer . Typer ( no_args_is_help = True ) @app . command () def create (): print ( "Creating user: Hiro Hamada" ) @app . command () def delete (): print ( "Deleting user: Hiro Hamada" ) if __name__ == "__main__" : app () Now we can run this: // Check the help without having to type --help $ python main.py Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create delete Sorting of the commands ¶ Note that by design, Typer shows the commands in the order they've been declared. So, if we take our original example, with create and delete commands, and reverse the order in the Python file: Python 3.8+ import typer app = typer . Typer () @app . command () def delete (): print ( "Deleting user: Hiro Hamada" ) @app . command () def create (): print ( "Creating user: Hiro Hamada" ) if __name__ == "__main__" : app () Then we will see the delete command first in the help output: // Check the help $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: delete create Click Group ¶ If you come from Click, a typer.Typer app with subcommands is more or less the equivalent of a Click Group . Technical Details A typer.Typer app is not a Click Group, but it provides the equivalent functionality. And it creates a Click Group when calling it. It is not directly a Group because Typer doesn't modify the functions in your code to convert them to another type of object, it only registers them. Decorator Technical Details ¶ When you use @app.command() the function under the decorator is registered in the Typer application and is then used later by the application. But Typer doesn't modify that function itself, the function is left as is. That means that if your function is simple enough that you could create it without using typer.Option() or typer.Argument() , you could use the same function for a Typer application and a FastAPI application putting both decorators on top, or similar tricks. Click Technical Details This behavior is a design difference with Click. In Click, when you add a @click.command() decorator it actually modifies the function underneath and replaces it with an object.

--- Content from https://typer.tiangolo.com/tutorial/commands/arguments/ ---

Typer Learn Commands Command CLI Arguments ¶ The same way as with a CLI application with a single command, subcommands (or just "commands") can also have their own CLI arguments : Python 3.8+ import typer app = typer . Typer () @app . command () def create ( username : str ): print ( f "Creating user: { username } " ) @app . command () def delete ( username : str ): print ( f "Deleting user: { username } " ) if __name__ == "__main__" : app () // Check the help for create $ python main.py create --help Usage: main.py create [OPTIONS] USERNAME Options: --help Show this message and exit. // Call it with a CLI argument $ python main.py create Camila Creating user: Camila // The same for delete $ python main.py delete Camila Deleting user: Camila Tip Everything to the right of the command are CLI parameters ( CLI arguments and CLI options ) for that command. Technical Details Actually, it's everything to the right of that command, before any subcommand . It's possible to have groups of subcommands , it's like if one command also had subcommands . And then those subcommands could have their own CLI parameters , taking their own CLI parameters . You will see about them later in another section.

--- Content from https://typer.tiangolo.com/tutorial/commands/callback/ ---

Typer Learn Commands Typer Callback ¶ When you create an app = typer.Typer() it works as a group of commands. And you can create multiple commands with it. Each of those commands can have their own CLI parameters . But as those CLI parameters are handled by each of those commands, they don't allow us to create CLI parameters for the main CLI application itself. But we can use @app.callback() for that. It's very similar to @app.command() , but it declares the CLI parameters for the main CLI application (before the commands): Python 3.8+ import typer app = typer . Typer () state = { "verbose" : False } @app . command () def create ( username : str ): if state [ "verbose" ]: print ( "About to create a user" ) print ( f "Creating user: { username } " ) if state [ "verbose" ]: print ( "Just created a user" ) @app . command () def delete ( username : str ): if state [ "verbose" ]: print ( "About to delete a user" ) print ( f "Deleting user: { username } " ) if state [ "verbose" ]: print ( "Just deleted a user" ) @app . callback () def main ( verbose : bool = False ): """ Manage users in the awesome CLI app. """ if verbose : print ( "Will write verbose output" ) state [ "verbose" ] = True if __name__ == "__main__" : app () Here we create a callback with a --verbose CLI option . Tip After getting the --verbose flag, we modify a global state , and we use it in the other commands. There are other ways to achieve the same, but this will suffice for this example. And as we added a docstring to the callback function, by default it will be extracted and used as the help text. Check it: // Check the help $ python main.py --help // Notice the main help text, extracted from the callback function: "Manage users in the awesome CLI app." Usage: main.py [OPTIONS] COMMAND [ARGS]... Manage users in the awesome CLI app. Options: --verbose / --no-verbose [default: False] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create delete // Check the new top level CLI option --verbose // Try it normally $ python main.py create Camila Creating user: Camila // And now with --verbose $ python main.py --verbose create Camila Will write verbose output About to create a user Creating user: Camila Just created a user // Notice that --verbose belongs to the callback, it has to go before create or delete ⛔️ $ python main.py create --verbose Camila Usage: main.py create [OPTIONS] USERNAME Try "main.py create --help" for help. Error: No such option: --verbose Adding a callback on creation ¶ It's also possible to add a callback when creating the typer.Typer() app: Python 3.8+ import typer def callback (): print ( "Running a command" ) app = typer . Typer ( callback = callback ) @app . command () def create ( name : str ): print ( f "Creating user: { name } " ) if __name__ == "__main__" : app () That achieves the same as with @app.callback() . Check it: $ python main.py create Camila Running a command Creating user: Camila Overriding a callback ¶ If you added a callback when creating the typer.Typer() app, it's possible to override it with @app.callback() : Python 3.8+ import typer def callback (): print ( "Running a command" ) app = typer . Typer ( callback = callback ) @app . callback () def new_callback (): print ( "Override callback, running a command" ) @app . command () def create ( name : str ): print ( f "Creating user: { name } " ) if __name__ == "__main__" : app () Now new_callback() will be the one used. Check it: $ python main.py create Camila // Notice that the message is the one from new_callback() Override callback, running a command Creating user: Camila Adding a callback only for documentation ¶ You can also add a callback just to add the documentation in the docstring. It can be convenient especially if you have several lines of text, as the indentation will be automatically handled for you: Python 3.8+ import typer app = typer . Typer () @app . callback () def callback (): """ Manage users CLI app. Use it with the create command. A new user with the given NAME will be created. """ @app . command () def create ( name : str ): print ( f "Creating user: { name } " ) if __name__ == "__main__" : app () Now the callback will be used mainly to extract the docstring for the help text. Check it: $ python main.py --help // Notice all the help text extracted from the callback docstring Usage: main.py [OPTIONS] COMMAND [ARGS]... Manage users CLI app. Use it with the create command. A new user with the given NAME will be created. Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create // And it just works as normally $ python main.py create Camila Creating user: Camila Click Group ¶ If you come from Click, this Typer callback is the equivalent of the function in a Click Group . For example: import click @click . group () def cli (): pass The original function cli would be the equivalent of a Typer callback. Technical Details When using Click, it converts that cli variable to a Click Group object. And then the original function no longer exists in that variable. Typer doesn't do that, the callback function is not modified, only registered in the typer.Typer app. This is intentional, it's part of Typer 's design, to allow having editor auto completion and type checks.

--- Content from https://typer.tiangolo.com/tutorial/commands/context/ ---

Typer Learn Commands Using the Context ¶ When you create a Typer application it uses Click underneath. And every Click application has a special object called a "Context" that is normally hidden. But you can access the context by declaring a function parameter of type typer.Context . You might have read it in CLI Option Callback and Context . The same way, in commands or in the main Typer callback you can access the context by declaring a function parameter of type typer.Context . Getting the context ¶ For example, let's say that you want to execute some logic in a Typer callback depending on the subcommand that is being called. You can get the name of the subcommand from the context: Python 3.8+ import typer app = typer . Typer () @app . command () def create ( username : str ): print ( f "Creating user: { username } " ) @app . command () def delete ( username : str ): print ( f "Deleting user: { username } " ) @app . callback () def main ( ctx : typer . Context ): """ Manage users in the awesome CLI app. """ print ( f "About to execute command: { ctx . invoked_subcommand } " ) if __name__ == "__main__" : app () Check it: $ python main.py create Camila // We get the message from the callback About to execute command: create Creating user: Camila $ python main.py delete Camila // We get the message from the callback, this time with delete About to execute command: delete Deleting user: Camila Executable callback ¶ By default, the callback is only executed right before executing a command. And if no command is provided, the help message is shown. But we could make it run even without a subcommand with invoke_without_command=True : Python 3.8+ import typer app = typer . Typer () @app . command () def create ( username : str ): print ( f "Creating user: { username } " ) @app . command () def delete ( username : str ): print ( f "Deleting user: { username } " ) @app . callback ( invoke_without_command = True ) def main (): """ Manage users in the awesome CLI app. """ print ( "Initializing database" ) if __name__ == "__main__" : app () Check it: $ python main.py // The callback is executed, we don't get the default help message Initializing database // Try with a command $ python main.py create Camila // The callback is still executed Initializing database Creating user: Camila Exclusive executable callback ¶ We might not want the callback to be executed if there's already other command that will be executed. For that, we can get the typer.Context and check if there's an invoked command in ctx.invoked_subcommand . If it's None , it means that we are not calling a subcommand but the main program (the callback) directly: Python 3.8+ import typer app = typer . Typer () @app . command () def create ( username : str ): print ( f "Creating user: { username } " ) @app . command () def delete ( username : str ): print ( f "Deleting user: { username } " ) @app . callback ( invoke_without_command = True ) def main ( ctx : typer . Context ): """ Manage users in the awesome CLI app. """ if ctx . invoked_subcommand is None : print ( "Initializing database" ) if __name__ == "__main__" : app () Check it: $ python main.py // The callback is executed Initializing database // Check it with a subcommand $ python main.py create Camila // This time the callback is not executed Creating user: Camila Configuring the context ¶ You can pass configurations for the context when creating a command or callback. To read more about the available configurations check the docs for Click's Context . For example, you could keep additional CLI parameters not declared in your CLI program with ignore_unknown_options and allow_extra_args . Then you can access those extra raw CLI parameters as a list of str in ctx.args : Python 3.8+ import typer app = typer . Typer () @app . command ( context_settings = { "allow_extra_args" : True , "ignore_unknown_options" : True } ) def main ( ctx : typer . Context ): for extra_arg in ctx . args : print ( f "Got extra arg: { extra_arg } " ) if __name__ == "__main__" : app () $ python main.py --name Camila --city Berlin Got extra arg: --name Got extra arg: Camila Got extra arg: --city Got extra arg: Berlin Tip Notice that it saves all the extra CLI parameters as a raw list of str , including the CLI option names and values, everything together.

--- Content from https://typer.tiangolo.com/tutorial/commands/help/ ---

Typer Learn Commands Command Help ¶ The same as before, you can add help for the commands in the docstrings and the CLI options . And the typer.Typer() application receives a parameter help that you can pass with the main help text for your CLI program: Python 3.8+ import typer from typing_extensions import Annotated app = typer . Typer ( help = "Awesome CLI user manager." ) @app . command () def create ( username : str ): """ Create a new user with USERNAME. """ print ( f "Creating user: { username } " ) @app . command () def delete ( username : str , force : Annotated [ bool , typer . Option ( prompt = "Are you sure you want to delete the user?" , help = "Force deletion without confirmation." , ), ], ): """ Delete a user with USERNAME. If --force is not used, will ask for confirmation. """ if force : print ( f "Deleting user: { username } " ) else : print ( "Operation cancelled" ) @app . command () def delete_all ( force : Annotated [ bool , typer . Option ( prompt = "Are you sure you want to delete ALL users?" , help = "Force deletion without confirmation." , ), ], ): """ Delete ALL users in the database. If --force is not used, will ask for confirmation. """ if force : print ( "Deleting all users" ) else : print ( "Operation cancelled" ) @app . command () def init (): """ Initialize the users database. """ print ( "Initializing user database" ) if __name__ == "__main__" : app () 🤓 Other versions and variants Python 3.8+ - non-Annotated Tip Prefer to use the Annotated version if possible. import typer app = typer . Typer ( help = "Awesome CLI user manager." ) @app . command () def create ( username : str ): """ Create a new user with USERNAME. """ print ( f "Creating user: { username } " ) @app . command () def delete ( username : str , force : bool = typer . Option ( ... , prompt = "Are you sure you want to delete the user?" , help = "Force deletion without confirmation." , ), ): """ Delete a user with USERNAME. If --force is not used, will ask for confirmation. """ if force : print ( f "Deleting user: { username } " ) else : print ( "Operation cancelled" ) @app . command () def delete_all ( force : bool = typer . Option ( ... , prompt = "Are you sure you want to delete ALL users?" , help = "Force deletion without confirmation." , ), ): """ Delete ALL users in the database. If --force is not used, will ask for confirmation. """ if force : print ( "Deleting all users" ) else : print ( "Operation cancelled" ) @app . command () def init (): """ Initialize the users database. """ print ( "Initializing user database" ) if __name__ == "__main__" : app () Check it: // Check the new help $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Awesome CLI user manager. Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create Create a new user with USERNAME. delete Delete a user with USERNAME. delete-all Delete ALL users in the database. init Initialize the users database. // Now the commands have inline help 🎉 // Check the help for create $ python main.py create --help Usage: main.py create [OPTIONS] USERNAME Create a new user with USERNAME. Options: --help Show this message and exit. // Check the help for delete $ python main.py delete --help Usage: main.py delete [OPTIONS] USERNAME Delete a user with USERNAME. If --force is not used, will ask for confirmation. Options: --force / --no-force Force deletion without confirmation. [required] --help Show this message and exit. // Check the help for delete-all $ python main.py delete-all --help Usage: main.py delete-all [OPTIONS] Delete ALL users in the database. If --force is not used, will ask for confirmation. Options: --force / --no-force Force deletion without confirmation. [required] --help Show this message and exit. // Check the help for init $ python main.py init --help Usage: main.py init [OPTIONS] Initialize the users database. Options: --help Show this message and exit. Tip typer.Typer() receives several other parameters for other things, we'll see that later. You will also see how to use "Callbacks" later, and those include a way to add this same help message in a function docstring. Overwrite command help ¶ You will probably be better adding the help text as a docstring to your functions, but if for some reason you wanted to overwrite it, you can use the help function argument passed to @app.command() : Python 3.8+ import typer app = typer . Typer () @app . command ( help = "Create a new user with USERNAME." ) def create ( username : str ): """ Some internal utility function to create. """ print ( f "Creating user: { username } " ) @app . command ( help = "Delete a user with USERNAME." ) def delete ( username : str ): """ Some internal utility function to delete. """ print ( f "Deleting user: { username } " ) if __name__ == "__main__" : app () Check it: // Check the help $ python main.py --help // Notice it uses the help passed to @app.command() Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create Create a new user with USERNAME. delete Delete a user with USERNAME. // It uses "Create a new user with USERNAME." instead of "Some internal utility function to create." Deprecate a Command ¶ There could be cases where you have a command in your app that you need to deprecate, so that your users stop using it, even while it's still supported for a while. You can mark it with the parameter deprecated=True : Python 3.8+ import typer app = typer . Typer () @app . command () def create ( username : str ): """ Create a user. """ print ( f "Creating user: { username } " ) @app . command ( deprecated = True ) def delete ( username : str ): """ Delete a user. This is deprecated and will stop being supported soon. """ print ( f "Deleting user: { username } " ) if __name__ == "__main__" : app () And when you show the --help option you will see it's marked as " deprecated ": $ python main.py --help <b> </b><font color="#F4BF75"><b>Usage: </b></font><b>main.py [OPTIONS] COMMAND [ARGS]... </b> <b> </b> <font color="#A5A5A1">╭─ Options ─────────────────────────────────────────────────────────╮</font> <font color="#A5A5A1">│ </font><font color="#A1EFE4"><b>--install-completion</b></font> Install completion for the current │ <font color="#A5A5A1">│ shell. │</font> <font color="#A5A5A1">│ </font><font color="#A1EFE4"><b>--show-completion</b></font> Show completion for the current │ <font color="#A5A5A1">│ shell, to copy it or customize the │</font> <font color="#A5A5A1">│ installation. │</font> <font color="#A5A5A1">│ </font><font color="#A1EFE4"><b>--help</b></font> Show this message and exit. │ <font color="#A5A5A1">╰───────────────────────────────────────────────────────────────────╯</font> <font color="#A5A5A1">╭─ Commands ────────────────────────────────────────────────────────╮</font> <font color="#A5A5A1">│ </font><font color="#A1EFE4"><b>create </b></font> Create a user. │ <font color="#A5A5A1">│ </font><font color="#6B9F98"><b>delete </b></font> Delete a user. <font color="#F92672">(deprecated) </font> │ <font color="#A5A5A1">╰───────────────────────────────────────────────────────────────────╯</font> And if you check the --help for the deprecated command (in this example, the command delete ), it also shows it as deprecated: $ python main.py delete --help <b> </b><font color="#F4BF75"><b>Usage: </b></font><b>main.py delete [OPTIONS] USERNAME </b> <b> </b> <font color="#F92672">(deprecated) </font> Delete a user. This is deprecated and will stop being supported soon. <font color="#A5A5A1">╭─ Arguments ───────────────────────────────────────────────────────╮</font> <font color="#A5A5A1">│ </font><font color="#F92672">*</font> username <font color="#F4BF75"><b>TEXT</b></font> [default: None] <font color="#A6194C">[required]</font> │ <font color="#A5A5A1">╰───────────────────────────────────────────────────────────────────╯</font> <font color="#A5A5A1">╭─ Options ─────────────────────────────────────────────────────────╮</font> <font color="#A5A5A1">│ </font><font color="#A1EFE4"><b>--help</b></font> Show this message and exit. │ <font color="#A5A5A1">╰───────────────────────────────────────────────────────────────────╯</font> Rich Markdown and Markup ¶ If you have Rich installed as described in Printing and Colors , you can configure your app to enable markup text with the parameter rich_markup_mode . Then you can use more formatting in the docstrings and the help parameter for CLI arguments and CLI options . You will see more about it below. 👇 Info By default, rich_markup_mode is None if Rich is not installed, and "rich" if it is installed. In the latter case, you can set rich_markup_mode to None to disable rich text formatting. Rich Markup ¶ If you set rich_markup_mode="rich" when creating the typer.Typer() app, you will be able to use Rich Console Markup in the docstring, and even in the help for the CLI arguments and options: Python 3.8+ import typer from typing_extensions import Annotated app = typer . Typer ( rich_markup_mode = "rich" ) @app . command () def create ( username : Annotated [ str , typer . Argument ( help = "The username to be [green]created[/green]" ) ], ): """ [bold green]Create[/bold green] a new [italic]shinny[/italic] user. :sparkles: This requires a [underline]username[/underline]. """ print ( f "Creating user: { username } " ) @app . command ( help = "[bold red]Delete[/bold red] a user with [italic]USERNAME[/italic]." ) def delete ( username : Annotated [ str , typer . Argument ( help = "The username to be [red]deleted[/red]" ) ], force : Annotated [ bool , typer . Option ( help = "Force the [bold red]deletion[/bold red] :boom:" ) ] = False , ): """ Some internal utility function to delete. """ print ( f "Deleting user: { username } " ) if __name__ == "__main__" : app () 🤓 Other versions and variants Python 3.8+ - non-Annotated Tip Prefer to use the Annotated version if possible. import typer app = typer . Typer ( rich_markup_mode = "rich" ) @app . command () def create ( username : str = typer . Argument ( ... , help = "The username to be [green]created[/green]" ), ): """ [bold green]Create[/bold green] a new [italic]shiny[/italic] user. :sparkles: This requires a [underline]username[/underline]. """ print ( f "Creating user: { username } " ) @app . command ( help = "[bold red]Delete[/bold red] a user with [italic]USERNAME[/italic]." ) def delete ( username : str = typer . Argument ( ... , help = "The username to be [red]deleted[/red]" ), force : bool = typer . Option ( False , help = "Force the [bold red]deletion[/bold red] :boom:" ), ): """ Some internal utility function to delete. """ print ( f "Deleting user: { username } " ) if __name__ == "__main__" : app () With that, you can use Rich Console Markup to format the text in the docstring for the command create , make the word " create " bold and green, and even use an emoji . You can also use markup in the help for the username CLI Argument. And the same as before, the help text overwritten for the command delete can also use Rich Markup, the same in the CLI Argument and CLI Option. If you run the program and check the help, you will see that Typer uses Rich internally to format the help. Check the help for the create command: $ python main.py create --help <b> </b><font color="#F4BF75"><b>Usage: </b></font><b>main.py create [OPTIONS] USERNAME </b> <b> </b> <font color="#A6E22E"><b>Create</b></font> a new <i>shiny</i> user. ✨ This requires a <font color="#A5A5A1"><u style="text-decoration-style:single">username</u></font><font color="#A5A5A1">. </font> <font color="#A5A5A1">╭─ Arguments ───────────────────────────────────────────────────────╮</font> <font color="#A5A5A1">│ </font><font color="#F92672">*</font> username <font color="#F4BF75"><b>TEXT</b></font> The username to be <font color="#A6E22E">created</font> │ <font color="#A5A5A1">│ [default: None] │</font> <font color="#A5A5A1">│ </font><font color="#A6194C">[required] </font> │ <font color="#A5A5A1">╰───────────────────────────────────────────────────────────────────╯</font> <font color="#A5A5A1">╭─ Options ─────────────────────────────────────────────────────────╮</font> <font color="#A5A5A1">│ </font><font color="#A1EFE4"><b>--help</b></font> Show this message and exit. │ <font color="#A5A5A1">╰───────────────────────────────────────────────────────────────────╯</font> And check the help for the delete command: $ python main.py delete --help <b> </b><font color="#F4BF75"><b>Usage: </b></font><b>main.py delete [OPTIONS] USERNAME </b> <b> </b> <font color="#F92672"><b>Delete</b></font> a user with <i>USERNAME</i>. <font color="#A5A5A1">╭─ Arguments ───────────────────────────────────────────────────────╮</font> <font color="#A5A5A1">│ </font><font color="#F92672">*</font> username <font color="#F4BF75"><b>TEXT</b></font> The username to be <font color="#F92672">deleted</font> │ <font color="#A5A5A1">│ [default: None] │</font> <font color="#A5A5A1">│ </font><font color="#A6194C">[required] </font> │ <font color="#A5A5A1">╰───────────────────────────────────────────────────────────────────╯</font> <font color="#A5A5A1">╭─ Options ─────────────────────────────────────────────────────────╮</font> <font color="#A5A5A1">│ </font><font color="#A1EFE4"><b>--force</b></font> <font color="#AE81FF"><b>--no-force</b></font> Force the <font color="#F92672"><b>deletion</b></font> 💥 │ <font color="#A5A5A1">│ [default: no-force] │</font> <font color="#A5A5A1">│ </font><font color="#A1EFE4"><b>--help</b></font> Show this message and exit. │ <font color="#A5A5A1">╰───────────────────────────────────────────────────────────────────╯</font> Rich Markdown ¶ If you set rich_markup_mode="markdown" when creating the typer.Typer() app, you will be able to use Markdown in the docstring: Python 3.8+ import typer from typing_extensions import Annotated app = typer . Typer ( rich_markup_mode = "markdown" ) @app . command () def create ( username : Annotated [ str , typer . Argument ( help = "The username to be **created**" )], ): """ **Create** a new *shinny* user. :sparkles: * Create a username * Show that the username is created --- Learn more at the [Typer docs website](https://typer.tiangolo.com) """ print ( f "Creating user: { username } " ) @app . command ( help = "**Delete** a user with *USERNAME*." ) def delete ( username : Annotated [ str , typer . Argument ( help = "The username to be **deleted**" )], force : Annotated [ bool , typer . Option ( help = "Force the **deletion** :boom:" )] = False , ): """ Some internal utility function to delete. """ print ( f "Deleting user: { username } " ) if __name__ == "__main__" : app () 🤓 Other versions and variants Python 3.8+ - non-Annotated Tip Prefer to use the Annotated version if possible. import typer app = typer . Typer ( rich_markup_mode = "markdown" ) @app . command () def create ( username : str = typer . Argument ( ... , help = "The username to be **created**" )): """ **Create** a new *shiny* user. :sparkles: * Create a username * Show that the username is created --- Learn more at the [Typer docs website](https://typer.tiangolo.com) """ print ( f "Creating user: { username } " ) @app . command ( help = "**Delete** a user with *USERNAME*." ) def delete ( username : str = typer . Argument ( ... , help = "The username to be **deleted**" ), force : bool = typer . Option ( False , help = "Force the **deletion** :boom:" ), ): """ Some internal utility function to delete. """ print ( f "Deleting user: { username } " ) if __name__ == "__main__" : app () With that, you can use Markdown to format the text in the docstring for the command create , make the word " create " bold, show a list of items, and even use an emoji . And the same as before, the help text overwritten for the command delete can also use Markdown. Check the help for the create command: $ python main.py create --help <b> </b><font color="#F4BF75"><b>Usage: </b></font><b>main.py create [OPTIONS] USERNAME </b> <b> </b> <b>Create</b> a new <i>shiny</i> user. ✨ <font color="#F4BF75"><b> • </b></font><font color="#A5A5A1">Create a username </font> <font color="#F4BF75"><b> • </b></font><font color="#A5A5A1">Show that the username is created </font> <font color="#F4BF75">───────────────────────────────────────────────────────────────────</font> Learn more at the <font color="#44919F">Typer docs website</font> <font color="#A5A5A1">╭─ Arguments ───────────────────────────────────────────────────────╮</font> <font color="#A5A5A1">│ </font><font color="#F92672">*</font> username <font color="#F4BF75"><b>TEXT</b></font> The username to be <b>created</b> │ <font color="#A5A5A1">│ [default: None] │</font> <font color="#A5A5A1">│ </font><font color="#A6194C">[required] </font> │ <font color="#A5A5A1">╰───────────────────────────────────────────────────────────────────╯</font> <font color="#A5A5A1">╭─ Options ─────────────────────────────────────────────────────────╮</font> <font color="#A5A5A1">│ </font><font color="#A1EFE4"><b>--help</b></font> Show this message and exit. │ <font color="#A5A5A1">╰───────────────────────────────────────────────────────────────────╯</font> And the same for the delete command: $ python main.py delete --help <b> </b><font color="#F4BF75"><b>Usage: </b></font><b>main.py delete [OPTIONS] USERNAME </b> <b> </b> <b>Delete</b> a user with <i>USERNAME</i>. <font color="#A5A5A1">╭─ Arguments ───────────────────────────────────────────────────────╮</font> <font color="#A5A5A1">│ </font><font color="#F92672">*</font> username <font color="#F4BF75"><b>TEXT</b></font> The username to be <b>deleted</b> │ <font color="#A5A5A1">│ [default: None] │</font> <font color="#A5A5A1">│ </font><font color="#A6194C">[required] </font> │ <font color="#A5A5A1">╰───────────────────────────────────────────────────────────────────╯</font> <font color="#A5A5A1">╭─ Options ─────────────────────────────────────────────────────────╮</font> <font color="#A5A5A1">│ </font><font color="#A1EFE4"><b>--force</b></font> <font color="#AE81FF"><b>--no-force</b></font> Force the <b>deletion</b> 💥 │ <font color="#A5A5A1">│ [default: no-force] │</font> <font color="#A5A5A1">│ </font><font color="#A1EFE4"><b>--help</b></font> Show this message and exit. │ <font color="#A5A5A1">╰───────────────────────────────────────────────────────────────────╯</font> Info Notice that in Markdown you cannot define colors. For colors you might prefer to use Rich markup. Help Panels ¶ If you have many commands or CLI parameters, you might want to show their documentation in different panels when using the --help option. If you installed Rich as described in Printing and Colors , you can configure the panel to use for each command or CLI parameter. Help Panels for Commands ¶ To set the panel for a command you can pass the argument rich_help_panel with the name of the panel you want to use: Python 3.8+ import typer app = typer . Typer ( rich_markup_mode = "rich" ) @app . command () def create ( username : str ): """ [green]Create[/green] a new user. :sparkles: """ print ( f "Creating user: { username } " ) @app . command () def delete ( username : str ): """ [red]Delete[/red] a user. :fire: """ print ( f "Deleting user: { username } " ) @app . command ( rich_help_panel = "Utils and Configs" ) def config ( configuration : str ): """ [blue]Configure[/blue] the system. :wrench: """ print ( f "Configuring the system with: { configuration } " ) @app . command ( rich_help_panel = "Utils and Configs" ) def sync (): """ [blue]Synchronize[/blue] the system or something fancy like that. :recycle: """ print ( "Syncing the system" ) @app . command ( rich_help_panel = "Help and Others" ) def help (): """ Get [yellow]help[/yellow] with the system. :question: """ print ( "Opening help portal..." ) @app . command ( rich_help_panel = "Help and Others" ) def report (): """ [yellow]Report[/yellow] an issue. :bug: """ print ( "Please open a new issue online, not a direct message" ) if __name__ == "__main__" : app () Commands without a panel will be shown in the default panel Commands , and the rest will be shown in the next panels: $ python main.py --help <b> </b><font color="#F4BF75"><b>Usage: </b></font><b>main.py [OPTIONS] COMMAND [ARGS]... </b> <b> </b> <font color="#A5A5A1">╭─ Options ─────────────────────────────────────────────────────────╮</font> <font color="#A5A5A1">│ </font><font color="#A1EFE4"><b>--install-completion</b></font> Install completion for the current │ <font color="#A5A5A1">│ shell. │</font> <font color="#A5A5A1">│ </font><font color="#A1EFE4"><b>--show-completion</b></font> Show completion for the current │ <font color="#A5A5A1">│ shell, to copy it or customize the │</font> <font color="#A5A5A1">│ installation. │</font> <font color="#A5A5A1">│ </font><font color="#A1EFE4"><b>--help</b></font> Show this message and exit. │ <font color="#A5A5A1">╰───────────────────────────────────────────────────────────────────╯</font> <font color="#A5A5A1">╭─ Commands ────────────────────────────────────────────────────────╮</font> <font color="#A5A5A1">│ </font><font color="#A1EFE4"><b>create </b></font> <font color="#A6E22E">Create</font> a new user. ✨ │ <font color="#A5A5A1">│ </font><font color="#A1EFE4"><b>delete </b></font> <font color="#F92672">Delete</font> a user. 🔥 │ <font color="#A5A5A1">╰───────────────────────────────────────────────────────────────────╯</font> <font color="#A5A5A1">╭─ Utils and Configs ───────────────────────────────────────────────╮</font> <font color="#A5A5A1">│ </font><font color="#A1EFE4"><b>config </b></font> <font color="#66D9EF">Configure</font> the system. 🔧 │ <font color="#A5A5A1">│ </font><font color="#A1EFE4"><b>sync </b></font> <font color="#66D9EF">Synchronize</font> the system or something fancy like that. ♻ │ <font color="#A5A5A1">╰───────────────────────────────────────────────────────────────────╯</font> <font color="#A5A5A1">╭─ Help and Others ─────────────────────────────────────────────────╮</font> <font color="#A5A5A1">│ </font><font color="#A1EFE4"><b>help </b></font> Get <font color="#F4BF75">help</font> with the system. ❓ │ <font color="#A5A5A1">│ </font><font color="#A1EFE4"><b>report </b></font> <font color="#F4BF75">Report</font> an issue. 🐛 │ <font color="#A5A5A1">╰───────────────────────────────────────────────────────────────────╯</font> Help Panels for CLI Parameters ¶ The same way, you can configure the panels for CLI arguments and CLI options with rich_help_panel . And of course, in the same application you can also set the rich_help_panel for commands. Python 3.8+ from typing import Union import typer from typing_extensions import Annotated app = typer . Typer ( rich_markup_mode = "rich" ) @app . command () def create ( username : Annotated [ str , typer . Argument ( help = "The username to create" )], lastname : Annotated [ str , typer . Argument ( help = "The last name of the new user" , rich_help_panel = "Secondary Arguments" ), ] = "" , force : Annotated [ bool , typer . Option ( help = "Force the creation of the user" )] = False , age : Annotated [ Union [ int , None ], typer . Option ( help = "The age of the new user" , rich_help_panel = "Additional Data" ), ] = None , favorite_color : Annotated [ Union [ str , None ], typer . Option ( help = "The favorite color of the new user" , rich_help_panel = "Additional Data" , ), ] = None , ): """ [green]Create[/green] a new user. :sparkles: """ print ( f "Creating user: { username } " ) @app . command ( rich_help_panel = "Utils and Configs" ) def config ( configuration : str ): """ [blue]Configure[/blue] the system. :wrench: """ print ( f "Configuring the system with: { configuration } " ) if __name__ == "__main__" : app () 🤓 Other versions and variants Python 3.8+ - non-Annotated Tip Prefer to use the Annotated version if possible. from typing import Union import typer app = typer . Typer ( rich_markup_mode = "rich" ) @app . command () def create ( username : str = typer . Argument ( ... , help = "The username to create" ), lastname : str = typer . Argument ( "" , help = "The last name of the new user" , rich_help_panel = "Secondary Arguments" ), force : bool = typer . Option ( False , help = "Force the creation of the user" ), age : Union [ int , None ] = typer . Option ( None , help = "The age of the new user" , rich_help_panel = "Additional Data" ), favorite_color : Union [ str , None ] = typer . Option ( None , help = "The favorite color of the new user" , rich_help_panel = "Additional Data" , ), ): """ [green]Create[/green] a new user. :sparkles: """ print ( f "Creating user: { username } " ) @app . command ( rich_help_panel = "Utils and Configs" ) def config ( configuration : str ): """ [blue]Configure[/blue] the system. :wrench: """ print ( f "Configuring the system with: { configuration } " ) if __name__ == "__main__" : app () Then if you run the application you will see all the CLI parameters in their respective panels. First the CLI arguments that don't have a panel name set in a default one named " Arguments ". Next the CLI arguments with a custom panel . In this example named " Secondary Arguments ". After that, the CLI options that don't have a panel in a default one named " Options ". And finally, the CLI options with a custom panel set. In this example named " Additional Data ". You can check the --help option for the command create : $ python main.py create --help <b> </b><font color="#F4BF75"><b>Usage: </b></font><b>main.py create [OPTIONS] USERNAME [LASTNAME] </b> <b> </b> <font color="#A6E22E">Create</font> a new user. ✨ <font color="#A5A5A1">╭─ Arguments ───────────────────────────────────────────────────────╮</font> <font color="#A5A5A1">│ </font><font color="#F92672">*</font> username <font color="#F4BF75"><b>TEXT</b></font> The username to create [default: None] │ <font color="#A5A5A1">│ </font><font color="#A6194C">[required] </font> │ <font color="#A5A5A1">╰───────────────────────────────────────────────────────────────────╯</font> <font color="#A5A5A1">╭─ Secondary Arguments ─────────────────────────────────────────────╮</font> <font color="#A5A5A1">│ lastname </font><font color="#A37F4E"><b>[LASTNAME]</b></font> The last name of the new user │ <font color="#A5A5A1">╰───────────────────────────────────────────────────────────────────╯</font> <font color="#A5A5A1">╭─ Options ─────────────────────────────────────────────────────────╮</font> <font color="#A5A5A1">│ </font><font color="#A1EFE4"><b>--force</b></font> <font color="#AE81FF"><b>--no-force</b></font> Force the creation of the user │ <font color="#A5A5A1">│ [default: no-force] │</font> <font color="#A5A5A1">│ </font><font color="#A1EFE4"><b>--help</b></font> Show this message and exit. │ <font color="#A5A5A1">╰───────────────────────────────────────────────────────────────────╯</font> <font color="#A5A5A1">╭─ Additional Data ─────────────────────────────────────────────────╮</font> <font color="#A5A5A1">│ </font><font color="#A1EFE4"><b>--age</b></font> <font color="#F4BF75"><b>INTEGER</b></font> The age of the new user │ <font color="#A5A5A1">│ [default: None] │</font> <font color="#A5A5A1">│ </font><font color="#A1EFE4"><b>--favorite-color</b></font> <font color="#F4BF75"><b>TEXT </b></font> The favorite color of the new │ <font color="#A5A5A1">│ user │</font> <font color="#A5A5A1">│ [default: None] │</font> <font color="#A5A5A1">╰───────────────────────────────────────────────────────────────────╯</font> And of course, the rich_help_panel can be used in the same way for commands in the same application. And those panels will be shown when you use the main --help option. $ python main.py --help <b> </b><font color="#F4BF75"><b>Usage: </b></font><b>main.py [OPTIONS] COMMAND [ARGS]... </b> <b> </b> <font color="#A5A5A1">╭─ Options ─────────────────────────────────────────────────────────╮</font> <font color="#A5A5A1">│ </font><font color="#A1EFE4"><b>--install-completion</b></font> Install completion for the current │ <font color="#A5A5A1">│ shell. │</font> <font color="#A5A5A1">│ </font><font color="#A1EFE4"><b>--show-completion</b></font> Show completion for the current │ <font color="#A5A5A1">│ shell, to copy it or customize the │</font> <font color="#A5A5A1">│ installation. │</font> <font color="#A5A5A1">│ </font><font color="#A1EFE4"><b>--help</b></font> Show this message and exit. │ <font color="#A5A5A1">╰───────────────────────────────────────────────────────────────────╯</font> <font color="#A5A5A1">╭─ Commands ────────────────────────────────────────────────────────╮</font> <font color="#A5A5A1">│ </font><font color="#A1EFE4"><b>create </b></font> <font color="#A6E22E">Create</font> a new user. ✨ │ <font color="#A5A5A1">╰───────────────────────────────────────────────────────────────────╯</font> <font color="#A5A5A1">╭─ Utils and Configs ───────────────────────────────────────────────╮</font> <font color="#A5A5A1">│ </font><font color="#A1EFE4"><b>config </b></font> <font color="#66D9EF">Configure</font> the system. 🔧 │ <font color="#A5A5A1">╰───────────────────────────────────────────────────────────────────╯</font> You can see the custom panel for the commands for " Utils and Configs ". Epilog ¶ If you need, you can also add an epilog section to the help of your commands: Python 3.8+ import typer app = typer . Typer ( rich_markup_mode = "rich" ) @app . command ( epilog = "Made with :heart: in [blue]Venus[/blue]" ) def create ( username : str ): """ [green]Create[/green] a new user. :sparkles: """ print ( f "Creating user: { username } " ) if __name__ == "__main__" : app () And when you check the --help option it will look like: $ python main.py --help <b> </b><font color="#F4BF75"><b>Usage: </b></font><b>main.py [OPTIONS] USERNAME </b> <b> </b> <font color="#A6E22E">Create</font> a new user. ✨ <font color="#A5A5A1">╭─ Arguments ───────────────────────────────────────────────────────╮</font> <font color="#A5A5A1">│ </font><font color="#F92672">*</font> username <font color="#F4BF75"><b>TEXT</b></font> [default: None] <font color="#A6194C">[required]</font> │ <font color="#A5A5A1">╰───────────────────────────────────────────────────────────────────╯</font> <font color="#A5A5A1">╭─ Options ─────────────────────────────────────────────────────────╮</font> <font color="#A5A5A1">│ </font><font color="#A1EFE4"><b>--install-completion</b></font> Install completion for the current │ <font color="#A5A5A1">│ shell. │</font> <font color="#A5A5A1">│ </font><font color="#A1EFE4"><b>--show-completion</b></font> Show completion for the current │ <font color="#A5A5A1">│ shell, to copy it or customize the │</font> <font color="#A5A5A1">│ installation. │</font> <font color="#A5A5A1">│ </font><font color="#A1EFE4"><b>--help</b></font> Show this message and exit. │ <font color="#A5A5A1">╰───────────────────────────────────────────────────────────────────╯</font> Made with ❤ in <font color="#66D9EF">Venus</font>

--- Content from https://typer.tiangolo.com/tutorial/commands/name/ ---

Typer Learn Commands Custom Command Name ¶ By default, the command names are generated from the function name. So, if your function is something like: def create ( username : str ): ... Then the command name will be create . But if you already had a function called create() somewhere in your code, you would have to name your CLI function differently. And what if you wanted the command to still be named create ? For this, you can set the name of the command in the first parameter for the @app.command() decorator: Python 3.8+ import typer app = typer . Typer () @app . command ( "create" ) def cli_create_user ( username : str ): print ( f "Creating user: { username } " ) @app . command ( "delete" ) def cli_delete_user ( username : str ): print ( f "Deleting user: { username } " ) if __name__ == "__main__" : app () Now, even though the functions are named cli_create_user() and cli_delete_user() , the commands will still be named create and delete : $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create delete // Test it $ python main.py create Camila Creating user: Camila Note that any underscores in the function name will be replaced with dashes. So if your function is something like: def create_user ( username : str ): ... Then the command name will be create-user .

--- Content from https://typer.tiangolo.com/tutorial/commands/one-or-multiple/ ---

Typer Learn Commands One or Multiple Commands ¶ You might have noticed that if you create a single command, as in the first example: Python 3.8+ import typer app = typer . Typer () @app . command () def main ( name : str ): print ( f "Hello { name } " ) if __name__ == "__main__" : app () Typer is smart enough to create a CLI application with that single function as the main CLI application, not as a command/subcommand: // Without a CLI argument $ python main.py Usage: main.py [OPTIONS] NAME Try "main.py --help" for help. Error: Missing argument 'NAME'. // With the NAME CLI argument $ python main.py Camila Hello Camila // Asking for help $ python main.py Usage: main.py [OPTIONS] NAME Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Tip Notice that it doesn't show a command main , even though the function name is main . But if you add multiple commands, Typer will create one CLI command for each one of them: Python 3.8+ import typer app = typer . Typer () @app . command () def create (): print ( "Creating user: Hiro Hamada" ) @app . command () def delete (): print ( "Deleting user: Hiro Hamada" ) if __name__ == "__main__" : app () Here we have 2 commands create and delete : // Check the help $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create delete // Test the commands $ python main.py create Creating user: Hiro Hamada $ python main.py delete Deleting user: Hiro Hamada One command and one callback ¶ If you want to create a CLI app with one single command but you still want it to be a command/subcommand you can just add a callback: Python 3.8+ import typer app = typer . Typer () @app . command () def create (): print ( "Creating user: Hiro Hamada" ) @app . callback () def callback (): pass if __name__ == "__main__" : app () And now your CLI program will have a single command. Check it: // Check the help $ python main.py --help // Notice the single command create Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create // Try it $ python main.py create Creating user: Hiro Hamada Using the callback to document ¶ Now that you are using a callback just to have a single command, you might as well use it to add documentation for your app: Python 3.8+ import typer app = typer . Typer () @app . command () def create (): print ( "Creating user: Hiro Hamada" ) @app . callback () def callback (): """ Creates a single user Hiro Hamada. In the next version it will create 5 more users. """ if __name__ == "__main__" : app () And now the docstring from the callback will be used as the help text: $ python main.py --help // Notice the help text from the docstring Usage: main.py [OPTIONS] COMMAND [ARGS]... Creates a single user Hiro Hamada. In the next version it will create 5 more users. Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create // And it still works the same, the callback does nothing $ python main.py create Creating user: Hiro Hamada

--- Content from https://typer.tiangolo.com/tutorial/commands/options/ ---

Typer Learn Commands Command CLI Options ¶ Commands can also have their own CLI options . In fact, each command can have different CLI arguments and CLI options : Python 3.8+ import typer from typing_extensions import Annotated app = typer . Typer () @app . command () def create ( username : str ): print ( f "Creating user: { username } " ) @app . command () def delete ( username : str , force : Annotated [ bool , typer . Option ( prompt = "Are you sure you want to delete the user?" ) ], ): if force : print ( f "Deleting user: { username } " ) else : print ( "Operation cancelled" ) @app . command () def delete_all ( force : Annotated [ bool , typer . Option ( prompt = "Are you sure you want to delete ALL users?" ) ], ): if force : print ( "Deleting all users" ) else : print ( "Operation cancelled" ) @app . command () def init (): print ( "Initializing user database" ) if __name__ == "__main__" : app () 🤓 Other versions and variants Python 3.8+ - non-Annotated Tip Prefer to use the Annotated version if possible. import typer app = typer . Typer () @app . command () def create ( username : str ): print ( f "Creating user: { username } " ) @app . command () def delete ( username : str , force : bool = typer . Option ( ... , prompt = "Are you sure you want to delete the user?" ), ): if force : print ( f "Deleting user: { username } " ) else : print ( "Operation cancelled" ) @app . command () def delete_all ( force : bool = typer . Option ( ... , prompt = "Are you sure you want to delete ALL users?" ), ): if force : print ( "Deleting all users" ) else : print ( "Operation cancelled" ) @app . command () def init (): print ( "Initializing user database" ) if __name__ == "__main__" : app () Here we have multiple commands, with different CLI parameters : create : username : a CLI argument . delete : username : a CLI argument . --force : a CLI option , if not provided, it's prompted. delete-all : --force : a CLI option , if not provided, it's prompted. init : Doesn't take any CLI parameters . // Check the help python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create delete delete-all init Tip Check the command delete-all , by default command names are generated from the function name, replacing _ with - . Test it: // Check the command create $ python main.py create Camila Creating user: Camila // Now test the command delete $ python main.py delete Camila # Are you sure you want to delete the user? [ y/n ] : $ y Deleting user: Camila $ python main.py delete Wade # Are you sure you want to delete the user? [ y/n ] : $ n Operation cancelled // And finally, the command delete-all // Notice it doesn't have CLI arguments, only a CLI option $ python main.py delete-all # Are you sure you want to delete ALL users? [ y/n ] : $ y Deleting all users $ python main.py delete-all # Are you sure you want to delete ALL users? [ y/n ] : $ n Operation cancelled // And if you pass the --force CLI option, it doesn't need to confirm $ python main.py delete-all --force Deleting all users // And init that doesn't take any CLI parameter $ python main.py init Initializing user database

